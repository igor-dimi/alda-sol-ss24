[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Algorithms & Data Structures Solutions - SoSe 24",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "01/01.html#aufgabe-2",
    "href": "01/01.html#aufgabe-2",
    "title": "1  Blatt 01",
    "section": "1.1 Aufgabe 2",
    "text": "1.1 Aufgabe 2\n\n\n\n\\[\\begin{align*}\n    \\log(n!) &= \\log(\\prod_{i=1}^{n}i) \\tag{Def $n!$} \\\\\n             &= \\sum_{i=1}^{n}\\log(i) \\tag{Eig $\\log(\\bullet)$} \\\\\n             &\\leq \\sum_{i=1}^{n}\\log(n) \\tag{Eig $\\log(\\bullet)$} \\\\\n             &= n\\log(n)\n\\end{align*}\\]\nWaehle nun \\(c_0 := 1\\) und \\(n_0 := 1\\). Es folgt somit:\n\\[\\begin{align*}\n     &\\log(n!) \\leq 1\\cdot n\\log(n), \\quad \\forall n \\geq 1 \\\\\n\\iff &\\log(n!) \\in \\mathcal{O}(n\\log(n)) \\tag{Def $\\mathcal{O}$}\n\\end{align*}\\]\n\n\n\nZuerst bemerken wir die folgende Eigenschaft\n\\[\\begin{align*}\n    n\\log(n) &\\leq c\\log(n!) \\\\\n\\iff       c &\\geq \\frac{n\\log(n)}{\\log(n!)} \\\\\n             &= \\frac{n\\log(n)}{\\sum_{i=1}^{n}\\log(i)}\n\\end{align*}\\]\nWir definieren die Folge:\n\\[\\begin{align*}\n    c(n) &:= \\frac{n\\log(n)}{\\sum_{i=1}^{n}\\log(i)} \\\\\n         &= \\frac{\\overbrace{\\log(n) + \\dots + \\log(n)}^\\text{n-mal}}{\\log(1) + \\dots + \\log(n)}\n\\end{align*}\\]\nWir behaupten ohne Beweis, dass \\(c(n)\\) eine monoton fallende Folge ist. D.h. es gilt:\n\\[\nc(n) \\leq c(m), \\quad \\forall n \\geq m\n\\]\nSetze nun \\(n_0 := 10, c_0 := c(10) = \\frac{10\\log(10)}{\\sum_{i = 1}^{10}\\log(i)}\\). Somit folgt:\n\\[\\begin{align*}\n    n\\log(n) &\\leq \\left(\\frac{n\\log(n)}{\\sum_{i=1}^{n}\\log(i)}\\right)\\log(n!) \\\\\n             &= c(n)\\log(n!) \\\\\n             &\\leq c_0\\log(n!), \\quad \\forall n\\geq n_0 = 10 \\tag{$c(n)$ monoton fallend}\n\\end{align*}\\]"
  },
  {
    "objectID": "01/01.html#aufgabe-3",
    "href": "01/01.html#aufgabe-3",
    "title": "1  Blatt 01",
    "section": "1.2 Aufgabe 3",
    "text": "1.2 Aufgabe 3\n\n1.2.1 a)\nDa \\(f_1 \\in \\mathcal{O}(g_1)\\) und \\(f_2 \\in \\mathcal{O}(g_2)\\) existieren \\(n_1, n_2, c_1, c_2\\) s.d:\n\\[\\begin{align*}\nf_1(n) \\leq c_1 g_1(n), \\quad \\forall n\\geq n_1 \\\\\nf_2(n) \\leq c_2 g_2(n), \\quad \\forall n\\geq n_2\n\\end{align*}\\]\nSetze \\(c_0 := max\\{c_1, c_2\\}, n_0 := max\\{n_1, n_2\\}\\). Dann gilt\n\\[\\begin{align*}\n    (f_1 + f_2)(n) &= f_1(n) + f_2(n)  \\\\\n                   &\\leq c_1g_1(n) + c_2g_2(n), \\quad \\forall n \\geq n_0\n                   \\tag{$n \\geq n_0 \\Rightarrow n \\geq n_1 \\wedge n \\geq n_2$} \\\\\n                   &\\leq c_0g_1(n) + c_0g_2(n), \\quad \\forall n \\geq n_0 \\\\\n                   &= c_0(g_1 + g_2)(n) \\quad \\forall n \\geq n_0 \\\\\n    \\iff   f_1 + f_2 &\\in \\mathcal{O}(g_1 + g_2) \\tag{Def $\\mathcal{O}$}\n\\end{align*}\\]\n\n\n1.2.2 b)\nmit \\(f_1 \\in \\Theta(g_1), f_2 \\in \\Theta(g_2)\\) existieren \\(a_1, a_2, b_1, b_2, n_1, n_2\\), s.d.:\n\\[\\begin{align*}\n    a_1f_1(n) \\leq g_1(n) \\leq a_2f_1(n), \\forall n \\geq n_1 \\\\\n    b_1f_2(n) \\leq g_2(n) \\leq b_2f_2(n), \\forall n \\geq n_2 \\\\\n\\end{align*}\\]\nSetze \\(n_0 := max\\{n_1, n_2\\}, \\, c_1 := a_1b_1, \\, c_2 := a_2b_2\\). Dann gilt:\n\\[\nc_1(f_1f_2)(n) = a_1f_1(n)b_1f_2(n) \\leq (g_1g_2)(n) \\leq a_2f_1(n)b_2f_2(n) = c_2(f_1f_2)(n), \\quad \\forall n \\geq n_0\n\\]\nSomit \\(f_1f_2 \\in \\Theta(g_1g_2)\\).\n\n\n1.2.3 c) Falsch:\nBetrachte \\(f(n) := n\\) und \\(g(n) := 10n\\). Offensichtlicht gilt \\(f \\in \\Omega(g)\\) mit \\(c_0 := 1/10, n_0 := 1\\). Aber \\(2^{n} \\notin \\Omega(2^{10n})\\), da \\(2^n\\) langsamer als \\(2^{10n}\\) waechst. (Setze z.B. \\(2^n := x\\). Dann \\(2^{10n} = (2^{n})^{10} = x^{10}\\), und \\(x^{10}\\) ist offensichtlich schneller als \\(x\\))\n\n\n1.2.4 d) Falsch:\nSei \\(g(n) := 2^n\\). Dann \\(f(n) = g(2n) = 2^{2n} = (2^n)^2\\). \\((2^n)^2\\) ist offensichtlich schneller als \\(2^n\\)\n\n\n1.2.5 e) Falsch:\nSeien \\(f(n) := n^2, f_1(n) := n^3, f_2(n) := n\\). Es gilt:\n\\[\\begin{align*}\n    f\\in \\mathcal{O}(f_1) \\tag{$n^2 \\in \\mathcal{O}(n^3)$} \\\\\n    f_1\\in \\Omega(f_2) \\tag{$n^3 \\in \\Omega(n)$}\n\\end{align*}\\]\naber\n\\[\nf \\notin \\mathcal{O}(f_2) \\tag{$n^2 \\notin \\mathcal{O}(n)$}\n\\]\n\n\n1.2.6 f)\nEs gilt:\n\\[\\begin{align*}\n    \\lim_{n\\to\\infty}\\frac{f(n)}{f_2(n)} &=\n                \\lim_{n\\to\\infty}\\left(\\frac{f(n)}{f_1(n)}\\cdot\\frac{f_1(n)}{f_2(n)}\\right) \\\\\n                                         &=\n                \\lim_{n\\to\\infty}\\left(\\frac{f(n)}{f_1(n)}\\right) \\cdot\n                \\lim_{n\\to\\infty}\\left(\\frac{f_1(n)}{f_2(n)}\\right) \\\\\n                                         &= 0\\cdot c, \\text{fuer ein} c\n                                         \\tag{$f \\in \\mathcal{o}(f_1), f_1 \\in\\mathcal{O}(f_2)$} \\\\\n                                         &= 0 \\\\\n                                \\iff f \\in \\mathcal{o}(f_2) \\tag{Def $\\mathcal{o}$}\n\\end{align*}\\]\nWobei wir die alternativen Definitionen von \\(\\mathcal{o}(\\bullet)\\) und \\(\\mathcal{O}(\\bullet)\\) benutzt haben."
  },
  {
    "objectID": "01/01.html#auafgabe-4",
    "href": "01/01.html#auafgabe-4",
    "title": "1  Blatt 01",
    "section": "1.3 Auafgabe 4",
    "text": "1.3 Auafgabe 4\n\n1.3.1 a)\n\\(\\mathcal{O}(n^2\\log(n))\\):\nread(n) //input\nfor i := 1 to n :\n    for j := 1 to n:\n        k := 1\n        // O(log(n))\n        while (k &lt; n) : \n            k := 2 * k\n\n\n1.3.2 b)\n\\(\\mathcal{O}((log(n))^2)\\):\nread(n) //input\ni := 1\nwhile (i &lt; n) :\n    j := 1\n    while (j &lt; n) :\n        j := 2 * j \n    i := 2 * i\n\n\n1.3.3 c)\nWir ‘simulieren’ Exponentiation durch einzelne Additionsoperationen. Somit ist \\(n^n\\) in \\(n^n\\) Additionen berechnet - Python Implementierung:\n\ndef add(n, m) :\n    if m == 0 : return n\n    return 1 + add(n, m - 1)\n\ndef mult(n, m) :\n    if m == 0 : return 0\n    return add(n, mult(n, m - 1))\n\ndef exp(n, m) :\n    if m == 0 : return 1\n    return mult(n, exp(n, m - 1))\n\ndef f(n) : return exp(n, n)\n\nWir testen diese Funktion fuer einige Werte:\n\nfor i in range(5) :\n    print(f(i))\n\n1\n1\n4\n27\n256\n\n\nAlternativ betrachte folgende rekursive Funktionsdefinition:\nfunction recursiveLoops(n : Nat, m : Nat) :\n    if m &gt; 0 then :\n        for i = 1 ... n do :\n            recursiveLoops(n, m - 1)\nDann erzeugt der Aufruf recursiveLoops(n, n)eine Anzahl von \\(\\mathcal{O}(n^n)\\) rekursiven Aufrufe.\n\n\n1.3.4 d)\n\\(\\Theta{2^n}\\) - Wir ‘simulieren’ binaeres Zaehlen:\nread(n)\nbase := 0\ncount := 0\nk := 1 \n// invariant: k == 2^b, count &lt; k\nwhile (base &lt; n) :\n    k := 2 * k\n    base := base + 1\n    while (count &lt; k) :\n        count := count + 1\n    // post-condition: count == k\n//post-condition b == n =&gt; count == 2^n\nPython Implementierung:\n\ndef binary_count(n) :\n    base = count = 0\n    k = 1\n    while (base &lt; n) :\n        k = 2 * k\n        base = base + 1\n        while (count &lt; k) :\n            count = count + 1\n    return count\n\nWir testen diese Funktion fuer einige Werte. Das Ergebniss ist die Anzahl der Schritte fuer die jeweilige Eingabe:\n\nfor i in range(11) :\n    print(binary_count(i))\n\n0\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n\n\nAlternativ:\nfunction f(n) :\n    if n == 0 : return 1\n    return f(n - 1) + f(n - 1)\nDiese rekursive Funktion ruft sich selbst zweimal fuer jeden Wert von \\(n\\) auf, was zu einer Laufzeit von \\(2^n\\) fuehrt."
  },
  {
    "objectID": "02/02.html#aufgabe-1",
    "href": "02/02.html#aufgabe-1",
    "title": "2  Blatt 2",
    "section": "2.1 Aufgabe 1",
    "text": "2.1 Aufgabe 1\n\n2.1.1 1\nRekursionsbaum des Aufrufs sum(&lt;1, 2, 3, 4, 5, 6, 7, 8&gt;)\n\n\n\nFigure 2.1: Rekursionsbaum\n\n\nDie Nummerierung der Knoten entspricht der Berechnungsreihenfolge.\n\n\n2.1.2 2\nEine nicht-konstante Laufzeit ensteht, falls uebergebene arrays auf den Stack des Funktionsaufrufs kopiert werden muessen.\nWenn eine gegebene Implementierung der Programmiersprache folgende zwei Eigenschaften aufweist, kann dies vermieden werden:\n\nDie Groesse eines Arrays ist immer als zusaetzliche Information beinhaltet.\nDie Funktionsaufrufe werden per-default als call by reference realisiert statt call by value.\n\nSo wuerde fuer einen existierenden Array \\(A : \\text{Array} [0 .. n - 1] \\text{ of } \\mathbb{N}\\) der allgeimeiner Ausdruck \\(A[l..k]\\) einen Array liefern, dessen Anfang-position im Speicher und Groesse durch Pointerarithmetik, bzw durch den Ausdruck \\(k - l + 1\\) bestimmt werden koennen. Das sind nur zwei Grundoperationen, und somit \\(\\mathcal{O}(1)\\)\nDa die Uebergabe der Arrays per Referenz stattfindet, wuerden die Aufrufe sum(A[0..m-1]) und sum(A[m..n-1]) nur konstante Zeit bei der Initialisuerungen auf ihren Function call-stacks benoetigen.\n\n\n2.1.3 3\n\nDie Laufzeit erfuellt die Rekurrenzgleichung:\n\n\\[\\begin{align*}\n    T(1) &= 1\\\\\n    T(n) &= 1 + 2\\cdot T(\\frac{n}{2}) \\tag{fuer $n = 2^k &gt; 1$}\n\\end{align*}\\]\n\nDa, die Eingabe bei jedem Aufruf halbiert wird ist die Tiefe des Rekurrenzbaums (Figure 2.1) \\(k = \\log_2(n)\\). Dieser Baum ist vollstaendig binaer, deshalb enthaelt jede Tiefe \\(i\\) genau \\(2^i\\) Knoten, fuer \\(i=0\\dots k\\). Somit betreagt die Gesamtzahl der Knoten:\n\n\\[\\begin{align*}\n    N &= \\sum_{i=0}^{\\log_2(n)}2^i \\\\\n      &= 2^{\\log_2(n) + 1} - 1 \\tag{Geom Reihe} \\\\\n      &= 2n - 1\n\\end{align*}\\]\nBei jedem Knoten wird eine konstante Anzahl von Additions- & Zuweisungsoperationen durchgefuehrt, und das Ergebnis zur aufrufenden Funktion zurueckgegeben. Somit ist die Laufzeit proportional zur Anzahl der Knoten, die wir in der vorangehenden Diskussion berechnet haben, d.h. \\(T(n) = c_1n + c_2\\). Dann gilt offensichtlich \\(T(n) = \\Theta(n)\\)"
  },
  {
    "objectID": "02/02.html#aufgabe-2",
    "href": "02/02.html#aufgabe-2",
    "title": "2  Blatt 2",
    "section": "2.2 Aufgabe 2",
    "text": "2.2 Aufgabe 2\n\n2.2.1 a)\n\\[\\begin{align*}\n    & a = 1, \\\\\n    &c = \\tilde{c}, \\\\\n    &d = 1 &lt; 2 = b \\\\\n    \\Rightarrow &T(n) \\in \\Theta(n) \\tag{Fall $d &lt; b$ des MT}\n\\end{align*}\\]\n\n\n2.2.2 b)\n\\[\\begin{align*}\n    & a = 1, \\\\\n    &c = 4, \\\\\n    &d = 9 &gt; 3 = b \\\\\n    \\Rightarrow &T(n) \\in \\Theta(n^{\\log_3(9)}) = \\Theta(n^2) \\tag{Fall $d &gt; b$ des MT}\n\\end{align*}\\]\n\n\n2.2.3 c)\nDer Ausdruck \\(C(n/4) + n + 6\\) kann asymptotisch als \\(C(n/4) + n\\) kann vereinfacht werden, da Addition mit konstante vernachlaessigt werden kann. Somit:\n\\[\\begin{align*}\n    & a = 1, \\\\\n    &c = 1, \\\\\n    &d = 1 &lt; 4 = b \\\\\n    \\Rightarrow &T(n) \\in \\Theta(n) \\tag{Fall $d &lt; b$ des MT}\n\\end{align*}\\]\n\n\n2.2.4 d)\nIn c) wurde gezeigt, dass \\(C(n) \\in \\Theta(n)\\). Somit kann \\(C(n)\\) fuer asymptotische Zwecke durch \\(c\\cdot n\\) erzetzt werden. Dann gilt:\n\\[\nT(n) = c\\cdot n + 4D(\\frac{n}{4})\n\\]\nund somit:\n\\[\\begin{align*}\n    &a = 1, \\\\\n    &d = 4 = 4 = b \\\\\n    \\Rightarrow &T(n) \\in \\Theta(n\\log n) \\tag{Fall $d = b$ des MT}\n\\end{align*}\\]"
  },
  {
    "objectID": "02/02.html#aufgabe-3",
    "href": "02/02.html#aufgabe-3",
    "title": "2  Blatt 2",
    "section": "2.3 Aufgabe 3",
    "text": "2.3 Aufgabe 3"
  }
]