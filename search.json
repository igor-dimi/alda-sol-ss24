[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Algorithms & Data Structures Solutions - SoSe 24",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "01/01.html",
    "href": "01/01.html",
    "title": "1  Blatt 1",
    "section": "",
    "text": "Aufgabe 2\n\\[\\begin{align*}\n    \\log(n!) &= \\log(\\prod_{i=1}^{n}i) \\tag{Def $n!$} \\\\\n             &= \\sum_{i=1}^{n}\\log(i) \\tag{Eig $\\log(\\bullet)$} \\\\\n             &\\leq \\sum_{i=1}^{n}\\log(n) \\tag{Eig $\\log(\\bullet)$} \\\\\n             &= n\\log(n)\n\\end{align*}\\]\nWaehle nun \\(c_0 := 1\\) und \\(n_0 := 1\\). Es folgt somit:\n\\[\\begin{align*}\n     &\\log(n!) \\leq 1\\cdot n\\log(n), \\quad \\forall n \\geq 1 \\\\\n\\iff &\\log(n!) \\in \\mathcal{O}(n\\log(n)) \\tag{Def $\\mathcal{O}$}\n\\end{align*}\\]\nZuerst bemerken wir die folgende Eigenschaft\n\\[\\begin{align*}\n    n\\log(n) &\\leq c\\log(n!) \\\\\n\\iff       c &\\geq \\frac{n\\log(n)}{\\log(n!)} \\\\\n             &= \\frac{n\\log(n)}{\\sum_{i=1}^{n}\\log(i)}\n\\end{align*}\\]\nWir definieren die Folge:\n\\[\\begin{align*}\n    c(n) &:= \\frac{n\\log(n)}{\\sum_{i=1}^{n}\\log(i)} \\\\\n         &= \\frac{\\overbrace{\\log(n) + \\dots + \\log(n)}^\\text{n-mal}}{\\log(1) + \\dots + \\log(n)}\n\\end{align*}\\]\nWir behaupten ohne Beweis, dass \\(c(n)\\) eine monoton fallende Folge ist. D.h. es gilt:\n\\[\nc(n) \\leq c(m), \\quad \\forall n \\geq m\n\\]\nSetze nun \\(n_0 := 10, c_0 := c(10) = \\frac{10\\log(10)}{\\sum_{i = 1}^{10}\\log(i)}\\). Somit folgt:\n\\[\\begin{align*}\n    n\\log(n) &\\leq \\left(\\frac{n\\log(n)}{\\sum_{i=1}^{n}\\log(i)}\\right)\\log(n!) \\\\\n             &= c(n)\\log(n!) \\\\\n             &\\leq c_0\\log(n!), \\quad \\forall n\\geq n_0 = 10 \\tag{$c(n)$ monoton fallend}\n\\end{align*}\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Blatt 1</span>"
    ]
  },
  {
    "objectID": "01/01.html#aufgabe-3",
    "href": "01/01.html#aufgabe-3",
    "title": "1  Blatt 1",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\n\na)\nDa \\(f_1 \\in  \\mathcal{O}(g_1)\\) und \\(f_2 \\in  \\mathcal{O}(g_2)\\) existieren \\(n_1, n_2, c_1, c_2\\) s.d:\n\\[\\begin{align*}\nf_1(n) \\leq c_1 g_1(n), \\quad \\forall n\\geq n_1 \\\\\nf_2(n) \\leq c_2 g_2(n), \\quad \\forall n\\geq n_2\n\\end{align*}\\]\nSetze \\(c_0 := max\\{c_1, c_2\\}, n_0 := max\\{n_1, n_2\\}\\). Dann gilt\n\\[\\begin{align*}\n    (f_1 + f_2)(n) &= f_1(n) + f_2(n)  \\\\\n                   &\\leq c_1g_1(n) + c_2g_2(n), \\quad \\forall n \\geq n_0\n                   \\tag{$n \\geq n_0 \\Rightarrow n \\geq n_1 \\wedge n \\geq n_2$} \\\\\n                   &\\leq c_0g_1(n) + c_0g_2(n), \\quad \\forall n \\geq n_0 \\\\\n                   &= c_0(g_1 + g_2)(n) \\quad \\forall n \\geq n_0 \\\\\n    \\iff   f_1 + f_2 &\\in \\mathcal{O}(g_1 + g_2) \\tag{Def $\\mathcal{O}$}\n\\end{align*}\\]\n\n\nb)\nmit \\(f_1 \\in \\Theta(g_1), f_2 \\in \\Theta(g_2)\\) existieren \\(a_1, a_2, b_1, b_2, n_1, n_2\\), s.d.:\n\\[\\begin{align*}\n    a_1f_1(n) \\leq g_1(n) \\leq a_2f_1(n), \\forall n \\geq n_1 \\\\\n    b_1f_2(n) \\leq g_2(n) \\leq b_2f_2(n), \\forall n \\geq n_2 \\\\\n\\end{align*}\\]\nSetze \\(n_0 := max\\{n_1, n_2\\}, \\, c_1 := a_1b_1, \\, c_2 := a_2b_2\\). Dann gilt:\n\\[\nc_1(f_1f_2)(n) = a_1f_1(n)b_1f_2(n) \\leq (g_1g_2)(n) \\leq a_2f_1(n)b_2f_2(n) = c_2(f_1f_2)(n), \\quad \\forall n \\geq n_0\n\\]\nSomit \\(f_1f_2 \\in \\Theta(g_1g_2)\\).\n\n\nc) Falsch:\nBetrachte \\(f(n) := n\\) und \\(g(n) := 10n\\). Offensichtlicht gilt \\(f \\in \\Omega(g)\\) mit \\(c_0 := 1/10, n_0 := 1\\). Aber \\(2^{n} \\notin \\Omega(2^{10n})\\), da \\(2^n\\) langsamer als \\(2^{10n}\\) waechst. (Setze z.B. \\(2^n := x\\). Dann \\(2^{10n} = (2^{n})^{10} = x^{10}\\), und \\(x^{10}\\) ist offensichtlich schneller als \\(x\\))\n\n\nd) Falsch:\nSei \\(g(n) := 2^n\\). Dann \\(f(n) = g(2n) = 2^{2n} = (2^n)^2\\). \\((2^n)^2\\) ist offensichtlich schneller als \\(2^n\\)\n\n\ne) Falsch:\nSeien \\(f(n) := n^2, f_1(n) := n^3, f_2(n) := n\\). Es gilt:\n\\[\\begin{align*}\n    f\\in \\mathcal{O}(f_1) \\tag{$n^2 \\in \\mathcal{O}(n^3)$} \\\\\n    f_1\\in \\Omega(f_2) \\tag{$n^3 \\in \\Omega(n)$}\n\\end{align*}\\]\naber\n\\[\nf \\notin \\mathcal{O}(f_2) \\tag{$n^2 \\notin \\mathcal{O}(n)$}\n\\]\n\n\nf)\nEs gilt:\n\\[\\begin{align*}\n    \\lim_{n\\to\\infty}\\frac{f(n)}{f_2(n)} &=\n                \\lim_{n\\to\\infty}\\left(\\frac{f(n)}{f_1(n)}\\cdot\\frac{f_1(n)}{f_2(n)}\\right) \\\\\n                                         &=\n                \\lim_{n\\to\\infty}\\left(\\frac{f(n)}{f_1(n)}\\right) \\cdot\n                \\lim_{n\\to\\infty}\\left(\\frac{f_1(n)}{f_2(n)}\\right) \\\\\n                                         &= 0\\cdot c, \\text{fuer ein} c\n                                         \\tag{$f \\in \\mathcal{o}(f_1), f_1 \\in\\mathcal{O}(f_2)$} \\\\\n                                         &= 0 \\\\\n                                \\iff f \\in \\mathcal{o}(f_2) \\tag{Def $\\mathcal{o}$}\n\\end{align*}\\]\nWobei wir die alternativen Definitionen von \\(\\mathcal{o}(\\bullet)\\) und \\(\\mathcal{O}(\\bullet)\\) benutzt haben.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Blatt 1</span>"
    ]
  },
  {
    "objectID": "01/01.html#auafgabe-4",
    "href": "01/01.html#auafgabe-4",
    "title": "1  Blatt 1",
    "section": "Auafgabe 4",
    "text": "Auafgabe 4\n\na)\n\\(\\mathcal{O}(n^2\\log(n))\\):\nread(n) //input\nfor i := 1 to n :\n    for j := 1 to n:\n        k := 1\n        // O(log(n))\n        while (k &lt; n) : \n            k := 2 * k\n\n\nb)\n\\(\\mathcal{O}((log(n))^2)\\):\nread(n) //input\ni := 1\nwhile (i &lt; n) :\n    j := 1\n    while (j &lt; n) :\n        j := 2 * j \n    i := 2 * i\n\n\nc)\nWir ‘simulieren’ Exponentiation durch einzelne Additionsoperationen. Somit ist \\(n^n\\) in \\(n^n\\) Additionen berechnet - Python Implementierung:\n\ndef add(n, m) :\n    if m == 0 : return n\n    return 1 + add(n, m - 1)\n\ndef mult(n, m) :\n    if m == 0 : return 0\n    return add(n, mult(n, m - 1))\n\ndef exp(n, m) :\n    if m == 0 : return 1\n    return mult(n, exp(n, m - 1))\n\ndef f(n) : return exp(n, n)\n\nWir testen diese Funktion fuer einige Werte:\n\nfor i in range(5) :\n    print(f(i))\n\n1\n1\n4\n27\n256\n\n\nAlternativ betrachte folgende rekursive Funktionsdefinition:\nfunction recursiveLoops(n : Nat, m : Nat) :\n    if m &gt; 0 then :\n        for i = 1 ... n do :\n            recursiveLoops(n, m - 1)\nDann erzeugt der Aufruf recursiveLoops(n, n)eine Anzahl von \\(\\mathcal{O}(n^n)\\) rekursiven Aufrufe.\n\n\nd)\n\\(\\Theta{2^n}\\) - Wir ‘simulieren’ binaeres Zaehlen:\nread(n)\nbase := 0\ncount := 0\nk := 1 \n// invariant: k == 2^b, count &lt; k\nwhile (base &lt; n) :\n    k := 2 * k\n    base := base + 1\n    while (count &lt; k) :\n        count := count + 1\n    // post-condition: count == k\n//post-condition b == n =&gt; count == 2^n\nPython Implementierung:\n\ndef binary_count(n) :\n    base = count = 0\n    k = 1\n    while (base &lt; n) :\n        k = 2 * k\n        base = base + 1\n        while (count &lt; k) :\n            count = count + 1\n    return count\n\nWir testen diese Funktion fuer einige Werte. Das Ergebniss ist die Anzahl der Schritte fuer die jeweilige Eingabe:\n\nfor i in range(11) :\n    print(binary_count(i))\n\n0\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n\n\nAlternativ:\nfunction f(n) :\n    if n == 0 : return 1\n    return f(n - 1) + f(n - 1)\nDiese rekursive Funktion ruft sich selbst zweimal fuer jeden Wert von \\(n\\) auf, was zu einer Laufzeit von \\(2^n\\) fuehrt.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Blatt 1</span>"
    ]
  },
  {
    "objectID": "02/02.html",
    "href": "02/02.html",
    "title": "2  Blatt 2",
    "section": "",
    "text": "Aufgabe 1",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Blatt 2</span>"
    ]
  },
  {
    "objectID": "02/02.html#aufgabe-1",
    "href": "02/02.html#aufgabe-1",
    "title": "2  Blatt 2",
    "section": "",
    "text": "1 Rekursionsbaum\nRekursionsbaum des Aufrufs sum(&lt;1, 2, 3, 4, 5, 6, 7, 8&gt;)\n\n\n\n\n\n\nFigure 2.1: Rekursionsbaum\n\n\n\nDie Nummerierung der Knoten entspricht der Berechnungsreihenfolge.\n\n\n2 Array Zerlegung\nEine nicht-konstante Laufzeit ensteht, falls uebergebene arrays auf den Stack des Funktionsaufrufs kopiert werden muessen.\nWenn eine gegebene Implementierung der Programmiersprache folgende zwei Eigenschaften aufweist, kann dies vermieden werden:\n\nDie Groesse eines Arrays ist immer als zusaetzliche Information beinhaltet.\nDie Funktionsaufrufe werden per-default als call by reference realisiert statt call by value.\n\nSo wuerde fuer einen existierenden Array \\(A : \\text{Array} [0 .. n - 1] \\text{ of } \\mathbb{N}\\) der allgeimeiner Ausdruck \\(A[l..k]\\) einen Array liefern, dessen Anfang-position im Speicher und Groesse durch Pointerarithmetik, bzw durch den Ausdruck \\(k - l + 1\\) bestimmt werden koennen. Das sind nur zwei Grundoperationen, und somit \\(\\mathcal{O}(1)\\)\nDa die Uebergabe der Arrays per Referenz stattfindet, wuerden die Aufrufe sum(A[0..m-1]) und sum(A[m..n-1]) nur konstante Zeit bei der Initialisuerungen auf ihren Function call-stacks benoetigen.\n\n\n3 Laufzeit\n\nDie Laufzeit erfuellt die Rekurrenzgleichung:\n\n\\[\\begin{align*}\n    T(1) &= 1\\\\\n    T(n) &= 1 + 2\\cdot T(\\frac{n}{2}) \\tag{fuer $n = 2^k &gt; 1$}\n\\end{align*}\\]\n\nDa, die Eingabe bei jedem Aufruf halbiert wird ist die Tiefe des Rekurrenzbaums (Figure 2.1) \\(k = \\log_2(n)\\). Dieser Baum ist vollstaendig binaer, deshalb enthaelt jede Tiefe \\(i\\) genau \\(2^i\\) Knoten, fuer \\(i=0\\dots k\\). Somit betreagt die Gesamtzahl der Knoten:\n\n\\[\\begin{align*}\n    N &= \\sum_{i=0}^{\\log_2(n)}2^i \\\\\n      &= 2^{\\log_2(n) + 1} - 1 \\tag{Geom Reihe} \\\\\n      &= 2n - 1\n\\end{align*}\\]\nBei jedem Knoten wird eine konstante Anzahl von Additions- & Zuweisungsoperationen durchgefuehrt, und das Ergebnis zur aufrufenden Funktion zurueckgegeben. Somit ist die Laufzeit proportional zur Anzahl der Knoten, die wir in der vorangehenden Diskussion berechnet haben, d.h. \\(T(n) = c_1n + c_2\\). Dann gilt offensichtlich \\(T(n) = \\Theta(n)\\)\n\n\n4 Laufzeit Parallel\nDa, der zweite rekursive Aufruf bereits berechnet ist zum Zeitpunkt der erste Fertig ist, muss sein Zeitaufwand nicht zuesaetzlich addiert werden. Somit erfuellt fuer diesen Fall die Laufzeit folgende Rekurrenzgleichung:\n\\[\\begin{align*}\n    T(1) &= 1\\\\\n    T(n) &= 1 + T(\\frac{n}{2}) \\tag{fuer $n = 2^k &gt; 1$}\n\\end{align*}\\]\nEs ist leicht zu sehen, dass \\(\\log_2(n)\\) diese Rekurrenzgleichung erfuellt. (Formaler Beweis durch Induktion). Dann \\(T(n) = \\mathcal{O}(\\log(n))\\)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Blatt 2</span>"
    ]
  },
  {
    "objectID": "02/02.html#aufgabe-2",
    "href": "02/02.html#aufgabe-2",
    "title": "2  Blatt 2",
    "section": "Aufgabe 2",
    "text": "Aufgabe 2\n\na)\n\\[\\begin{align*}\n    & a = 1, \\\\\n    &c = \\tilde{c}, \\\\\n    &d = 1 &lt; 2 = b \\\\\n    \\Rightarrow &T(n) \\in \\Theta(n) \\tag{Fall $d &lt; b$ des MT}\n\\end{align*}\\]\n\n\nb)\n\\[\\begin{align*}\n    & a = 1, \\\\\n    &c = 4, \\\\\n    &d = 9 &gt; 3 = b \\\\\n    \\Rightarrow &T(n) \\in \\Theta(n^{\\log_3(9)}) = \\Theta(n^2) \\tag{Fall $d &gt; b$ des MT}\n\\end{align*}\\]\n\n\nc)\nDer Ausdruck \\(C(n/4) + n + 6\\) kann asymptotisch als \\(C(n/4) + n\\) kann vereinfacht werden, da Addition mit konstante vernachlaessigt werden kann. Somit:\n\\[\\begin{align*}\n    & a = 1, \\\\\n    &c = 1, \\\\\n    &d = 1 &lt; 4 = b \\\\\n    \\Rightarrow &T(n) \\in \\Theta(n) \\tag{Fall $d &lt; b$ des MT}\n\\end{align*}\\]\n\n\nd)\nIn c) wurde gezeigt, dass \\(C(n) \\in \\Theta(n)\\). Somit kann \\(C(n)\\) fuer asymptotische Zwecke durch \\(c\\cdot n\\) erzetzt werden. Dann gilt:\n\\[\nT(n) = c\\cdot n + 4D(\\frac{n}{4})\n\\]\nund somit:\n\\[\\begin{align*}\n    &a = 1, \\\\\n    &d = 4 = 4 = b \\\\\n    \\Rightarrow &T(n) \\in \\Theta(n\\log n) \\tag{Fall $d = b$ des MT}\n\\end{align*}\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Blatt 2</span>"
    ]
  },
  {
    "objectID": "02/02.html#aufgabe-3",
    "href": "02/02.html#aufgabe-3",
    "title": "2  Blatt 2",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\n\n1 Doubly Linked List\nWir gehen von einer Implementierung aus, die das Dummy-element verwendent, wie in der VL beschrieben.\nIdee: Tausche fuer jedes List-Item die Pointer next und prev aus. Illustration:\n\n\n\nReverse DLList\n\n\n\nPseudocode implementierung:\n\nprocedure reverse(X : List&lt;T&gt;)\n    assert(not X.is_empty())\n    // let initially X == &lt;e1, ..., e_n&gt;\n\n    // exchange dummy's prev and next pointers\n    ip := X.first() : *Item&lt;T&gt;\n    X.first() := X.last()\n    X.last() := ip\n\n    // invariant: reversed from e1 up-to (excluding) *ip\n    while (ip-&gt;next != &dummy)\n        //exchange next and prev of the item pointed by ip\n        ip_next := ip-&gt;next : *Item&lt;T&gt;\n        ip-&gt;next := ip-&gt;prev\n        ip-&gt;prev := ip_next\n        ip = ip_next //increment to next item\n    //post-loop: *ip == e_n \n\n    // take care of e_n's pointers:\n    ip.next = ip.prev\n    ip.prev = &dummy\n\nSiehe Kommentare fuer den Beweis der Korrektheit\nDer Algorithmus benoetigt keine zusaetzliche Worte, da es keine neue Listenelemente abgelegt oder existierende Elemente kopiert werden. Es werden einfach nur Pointer ausgetauscht.\nDie Listenelemente werden sequentiell durchgelaufen und fuer jedes Element werden eine konstante Anzahl von Grundoperationen durchgefuehrt \\(\\Rightarrow \\mathcal{O}(n)\\).\n\n\n\n2 Array\nIdee: Tausche die ‘aussersten’ noch nicht ausgetauschten Elementen aus, und inkrementiere zu den inneren. Siehe das Bild:\n\n\n\nReverse Array\n\n\n\nPseudocode:\n\nprocedure reverse(X: Array[0..n-1] of Nat)\n    i := 0 : Nat\n    // invariant: the X[0..i-1] and X[(n-1) - (i-1) .. n-1]\n    // portions of X are reversed\n    while (i &lt; n/2)\n        temp := X[i] : Nat\n        X[i] := X[(n-1) - i]\n        X[(n-1) - i] := temp\n        i := i + 1\n    //post-loop: i == ceiling(n/2)\nPython Beispiel:\n\ndef reverse(X) :\n    i = 0\n    n = len(X)\n    while (i &lt; n/2) :\n        temp = X[i]\n        X[i] = X[(n-1) - i]\n        X[(n-1) - i] = temp\n        i = i + 1\n    return X\n    \nX = [1, 2, 3, 4]\nY = [1, 2, 3, 4, 5]\nZ = [1, 2, 3, 4, 5, 6]\n\nprint(reverse(X))\nprint(reverse(Y))\nprint(reverse(Z))\n\n[4, 3, 2, 1]\n[5, 4, 3, 2, 1]\n[6, 5, 4, 3, 2, 1]\n\n\n\nSiehe die Kommentare im Pseudocode fuer den Beweis der Korrektheit\nDer Algorithmus verwendet keine neue Worte, da die Eintrage des Arrays “in-place” ausgetauscht werden. D.h. der vorhandene Array wird ueberschrieben\nDer Algorithmus besteht aus einer while-schleife mit \\(n/2\\) iterationen \\(\\Rightarrow \\Theta(n)\\).\n\n\n\n3 Simply Linked List\nIdee: Gehe die Liste durch und drehe die Pointer fuer jedes Listenelement um. Siehe das Bild:\n\n\n\nReverse SList\n\n\n\nPseudocode:\n\nreverse(X : SList&lt;T&gt;)\n    assert(not X.is_empty())\n    // let &lt;e1,...,e_n&gt; be the initial contents of the list \n    // i.e. initially X == &lt;e1,...,e_n&gt;\n    ip := X.first() : *Item&lt;T&gt;      //*ip == e1\n    ip_next := ip-&gt;next : *Item&lt;T&gt;  //*ip_next == e2\n    ip-&gt;next := &dummy          //e1 is now last\n\n    //invariant: \n    // (*ip == e_k) =&gt; \n    // *ip_next == e_(k+1))\n    //   && \n    //reversed from e1 to e_k, i.e. X == &lt;..TBD..,e_k, ..., e1&gt;\n    while (ip_next != &dummy)\n        ip_next_next := ip_next-&gt;next : *Item&lt;T&gt;\n        ip_next-&gt;next := ip\n        ip := ip_next\n        ip_next := ip_next_next\n    //post-loop: *ip == e_n\n    \n    // take care of dummy's next pointer\n    X.first() := ip \n\nSiehe Kommentare im Pseudocode\nNur Pointer werden ueberschrieben \\(\\Rightarrow\\) keine extra Speicherbelegung.\nSequentielle Bearbeitung der Listenelemente \\(\\Rightarrow \\Theta(n)\\)\n\n\n\n4 Fast Reverse\nDas ist nicht moeglich, da Kopieren einer Liste oder eines Arrays der Laenge \\(n\\) \\(\\Theta(n)\\) Operationen benoetigen wuerde. Somit sind Algorithmen, die Listen- oder Arrayelemente kopieren mindestens \\(\\Theta(n)\\). Unsere “in-place” Algorithmen sind bereits \\(\\Theta(n)\\)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Blatt 2</span>"
    ]
  },
  {
    "objectID": "03/03.html",
    "href": "03/03.html",
    "title": "3  Blatt 3",
    "section": "",
    "text": "Aufgabe 1 - Amortisierte Komplexitaet\n\\[\n1\\,1\\,1\\,\\boxed{4}\\,1\\,\\dots\\,1\\,\\boxed{16}\\,1\\,\\dots\\,1\\,\\boxed{64}\\,\n1\\,\\dots\\,1\\,\\boxed{256}\\, 1 \\dots 1\n\\]\nInsgesamt gibt es \\(1001\\) Operationen. Nur \\(4\\) von diesen , naemlich \\(\\sigma_{4}, \\sigma_{16}, \\sigma_{64}, \\sigma_{256}\\) haben Kosten ungleich \\(1\\), und zwar \\(4^1, 4^2, 4^3, 4^4\\).\nSomit sind die Gesammtkosten:\n\\[\\begin{align*}\nT(1001) &= (1001 - 4) + 4^1 + 4^2 + 4^3 + 4^4 \\\\\n        &= 1337\n\\end{align*}\\]\n\\[\\begin{align*}\n    T(4^m) &= (4^m - m) + 4^1 + \\dots + 4^m \\\\\n           &= (4^m - m) +\n           \\frac{4^{m + 1} - 1}{3} - 1 \\tag{Geom. Reihe}\\\\\n           &= \\frac{7\\cdot 4^{m} - 1}{3} - (m + 1)\n\\end{align*}\\]\n\\[\\begin{align*}\n    \\frac{T(4^m)}{4^m} &= 7 - \\frac{1}{3\\cdot 4^m} - \\frac{m+1}{4^m} \\\\\n                       &\\in \\mathcal{O}(1)\n\\end{align*}\\]\nDas sind die amortisierten Kosten dieser Operationen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Blatt 3</span>"
    ]
  },
  {
    "objectID": "03/03.html#aufgabe-1---amortisierte-komplexitaet",
    "href": "03/03.html#aufgabe-1---amortisierte-komplexitaet",
    "title": "3  Blatt 3",
    "section": "",
    "text": "Es entsteht die Folge von Kosten:\n\n\n\n\n\n\nAnhand der Loesung vorheriger Teilaufgabe koennen wir die folgende geschlossene Form fuer \\(T(4^m)\\) angeben:\n\n\n\nIn der vorherigen Teilaufgabe haben wir die Zeitkosten fuer \\(4^m\\) Operationen berechnet. Die Zeitkosten pro Operation ist dann:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Blatt 3</span>"
    ]
  },
  {
    "objectID": "05/05.html",
    "href": "05/05.html",
    "title": "4  Blatt 5",
    "section": "",
    "text": "Aufgabe 3 (Sortieren)\nMatrikel Nr: 3650174",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Blatt 5</span>"
    ]
  },
  {
    "objectID": "05/05.html#aufgabe-3-sortieren",
    "href": "05/05.html#aufgabe-3-sortieren",
    "title": "4  Blatt 5",
    "section": "",
    "text": "Insertion Sort\nMit der folgenden Python Implementierung fuer Insertion-sort wird nach jedem Insert der Zustand des Arrays ausgegeben:\n\ndef insertion_sort(a) :\n    n = len(a)\n    # invariant: sorted a[0..i]\n    for i in range(1, n) :\n        # insert i in the right position\n        j = i - 1\n        el = a[i]\n        while el &lt; a[j] and j &gt; 0 :\n            a[j + 1] = a[j]\n            j = j - 1\n        # el &gt;= a[j] or j == 0\n        if el &lt; a[j] : # j == 0\n            a[1] = a[0]\n            a[0] = el\n        else : # el &gt;= a[j] \n            a[j + 1] = el\n        print(\"after insertion \", i, \": \", a)\n    return a\n\ninsertion_sort([3, 6, 5, 0, 1, 7, 4])\n\nafter insertion  1 :  [3, 6, 5, 0, 1, 7, 4]\nafter insertion  2 :  [3, 5, 6, 0, 1, 7, 4]\nafter insertion  3 :  [0, 3, 5, 6, 1, 7, 4]\nafter insertion  4 :  [0, 1, 3, 5, 6, 7, 4]\nafter insertion  5 :  [0, 1, 3, 5, 6, 7, 4]\nafter insertion  6 :  [0, 1, 3, 4, 5, 6, 7]\n\n\n[0, 1, 3, 4, 5, 6, 7]\n\n\n\n\nMerge Sort\nSiehe Abbildung:\n\n\n\nmerge sort\n\n\n\n\nQuick Sort\n1st call on 365017:\n\\[\\begin{align*}\n    &\\overset{i}{3}65017\\overset{j}{4} \\tag{p = 2} \\\\\n    \\Rightarrow &\\overset{i}{3}650\\overset{j}{1}74 \\tag{iterate i, j} \\\\\n    \\Rightarrow &\\boxed{3}650\\boxed{1}74 \\tag{swap 3, 1} \\\\\n    \\Rightarrow &1\\overset{i}{6}5\\overset{j}{0}374 \\tag{iterate i, j} \\\\\n    \\Rightarrow &1\\boxed{6}5\\boxed{0}374 \\tag{swap 6, 0} \\\\\n    \\Rightarrow &10\\overset{i,j}{5}6374 \\tag{iterate i, j} \\\\\n    \\Rightarrow &1\\overset{j}{0}|\\overset{i}{5}6374 \\tag{end}\n\\end{align*}\\]\n2nd level call 1 on 10:\n\\[\\begin{align*}\n    &\\overset{i}{1}\\overset{j}{0} \\tag{p = 1} \\\\\n    \\Rightarrow &\\overset{j}{0}\\overset{i}{1} \\tag{iterate i, j; swap 1, 0; end}\n\\end{align*}\\]\n2nd level call 2 on 56374:\n\\[\\begin{align*}\n    &\\overset{i}{\\boxed{5}}637\\overset{j}{\\boxed{4}} \\tag{p = 5, iterate, swap 5, 4} \\\\\n    \\Rightarrow &4\\overset{i}63\\overset{j}75 \\tag{iterate} \\\\\n    \\Rightarrow &4\\overset{i}{\\boxed{6}}\\overset{j}{\\boxed{3}}75 \\tag{swap} \\\\\n    \\Rightarrow &4\\overset{j}{3}|\\overset{i}{6}75 \\tag{end}\n\\end{align*}\\]\n3rd level call 1 on 43:\n\\[\\begin{align*}\n    &\\overset{i}{4}\\overset{j}{3} \\tag{p = 4} \\\\\n    \\Rightarrow &\\overset{j}{3}\\overset{i}{4} \\tag{iterate i, j; swap 4, 3; end}\n\\end{align*}\\]\n3rd level call 2 on 675:\n\\[\\begin{align*}\n    &\\overset{i}{6}7\\overset{j}{5} \\tag{p = 6} \\\\\n    \\Rightarrow &\\overset{i}{\\boxed{6}}7\\overset{j}{\\boxed{5}} \\tag{iterate; swap} \\\\\n    \\Rightarrow &5\\overset{ij}{7}6 \\tag{iterate} \\\\\n    \\Rightarrow &\\overset{j}{5}|7\\overset{i}{6} \\tag{end}\n\\end{align*}\\]\n4th level last call on 76:\n\\[\\begin{align*}\n    &\\overset{i}{7}\\overset{j}{6} \\tag{p = 7} \\\\\n    \\Rightarrow &\\overset{j}{6}\\overset{i}{7} \\tag{iterate i, j; swap 7, 6; end}\n\\end{align*}\\]\nalltogether:\n3 6 5 0 1 7 4\n1 0|5 6 3 7 4\n0 1|4 3|6 7 5\n   |3 4|5|7 6\n         |6 7\n\n=&gt; output: 0 1 3 4 5 6 7",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Blatt 5</span>"
    ]
  },
  {
    "objectID": "06/06.html",
    "href": "06/06.html",
    "title": "5  Blatt 6",
    "section": "",
    "text": "Aufgabe 1\ndef convert(x, base) :\n    if x == 0: return '0'\n    s = []\n    while (x &gt; 0) :\n        s.insert(0, str(x % base))\n        x = x // base\n    return \"\".join(s)\nund konvertieren die Zahlen in \\(A\\) anhand dieser Funktion auf Basis 7:\nA = [147, 44, 337, 528, 45, 622]\n[convert(x, 7) for x in A]\n\n['300', '62', '661', '1353', '63', '1546']\nWir sehen, dass die Zahlen hoechstens aus 4 Ziffern bestehen. Somit \\(d = 4\\).\n# sorts keys in range [0, 7)\ndef KSort7(s, key) :\n    # initialize orray of length 100 with empty buckets\n    b = []\n    for i in range(7) : b.append([])\n    # place elements in buckets\n    for el in s : b[key(el)].append(el)\n    # print state of the buckets\n    for i in range(7) :\n        print(\"bucket \", i, \": \", list(map(str, [convert(x, 7) for x in b[i]])))\n    # array holding results\n    res = []\n    # append elements in buckets to res\n    for i in range(7) :\n        for el in b[i] : res.append(el)\n    return res\nNun definieren die LSDRadixSort7() Funktion, die den Radix Sort algorithmus fuer Basis 7 anhand KSort7() implementiert.\ndef LSDRadixSort7(a) :\n    for i in range(4) :\n        print(\"d == \", i)\n        a = KSort7(a, lambda x : (x // 7**i) % 7)\n        print(\"\")\n    return a\nAm Ende jeder Iteration wird der Zustand von den Buckets anhand KSort7() ausgegeben. Wir rufen die Funktion auf \\(A\\) auf und konvertieren das Ergebniss zu Basis 7:\n[convert(x, 7) for x in LSDRadixSort7(A)]\n\nd ==  0\nbucket  0 :  ['300']\nbucket  1 :  ['661']\nbucket  2 :  ['62']\nbucket  3 :  ['1353', '63']\nbucket  4 :  []\nbucket  5 :  []\nbucket  6 :  ['1546']\n\nd ==  1\nbucket  0 :  ['300']\nbucket  1 :  []\nbucket  2 :  []\nbucket  3 :  []\nbucket  4 :  ['1546']\nbucket  5 :  ['1353']\nbucket  6 :  ['661', '62', '63']\n\nd ==  2\nbucket  0 :  ['62', '63']\nbucket  1 :  []\nbucket  2 :  []\nbucket  3 :  ['300', '1353']\nbucket  4 :  []\nbucket  5 :  ['1546']\nbucket  6 :  ['661']\n\nd ==  3\nbucket  0 :  ['62', '63', '300', '661']\nbucket  1 :  ['1353', '1546']\nbucket  2 :  []\nbucket  3 :  []\nbucket  4 :  []\nbucket  5 :  []\nbucket  6 :  []\n\n\n\n['62', '63', '300', '661', '1353', '1546']",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Blatt 6</span>"
    ]
  },
  {
    "objectID": "06/06.html#aufgabe-1",
    "href": "06/06.html#aufgabe-1",
    "title": "5  Blatt 6",
    "section": "",
    "text": "Zuerst definieren wir folgende Python Funktion fuer Konvertierung von Basis 10 auf basis x:\n\n\n\n\n\n\nJetzt geben wir die folgende Python implementierung fuer KSort7() an, die Schluessel im Bereich \\([0, 7)\\) sortiert. Die Funktion erhaelt einen zusaetzlichen funktionalen Paremeter, dadurch die key() Funktion bestimmt wird. Beachte, dass danach die Elemente in Buckets hinzugefuegt werden der Zustand von Buckets ausgegeben wird. Am Ende werden die Buckets konkateniert und das Ergebniss zurueckgegeben",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Blatt 6</span>"
    ]
  }
]