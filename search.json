[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Algorithms & Data Structures Solutions - SoSe 24",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "01/01.html",
    "href": "01/01.html",
    "title": "1  Blatt 1",
    "section": "",
    "text": "Aufgabe 2\n\\[\\begin{align*}\n    \\log(n!) &= \\log(\\prod_{i=1}^{n}i) \\tag{Def $n!$} \\\\\n             &= \\sum_{i=1}^{n}\\log(i) \\tag{Eig $\\log(\\bullet)$} \\\\\n             &\\leq \\sum_{i=1}^{n}\\log(n) \\tag{Eig $\\log(\\bullet)$} \\\\\n             &= n\\log(n)\n\\end{align*}\\]\nWaehle nun \\(c_0 := 1\\) und \\(n_0 := 1\\). Es folgt somit:\n\\[\\begin{align*}\n     &\\log(n!) \\leq 1\\cdot n\\log(n), \\quad \\forall n \\geq 1 \\\\\n\\iff &\\log(n!) \\in \\mathcal{O}(n\\log(n)) \\tag{Def $\\mathcal{O}$}\n\\end{align*}\\]\nZuerst bemerken wir die folgende Eigenschaft\n\\[\\begin{align*}\n    n\\log(n) &\\leq c\\log(n!) \\\\\n\\iff       c &\\geq \\frac{n\\log(n)}{\\log(n!)} \\\\\n             &= \\frac{n\\log(n)}{\\sum_{i=1}^{n}\\log(i)}\n\\end{align*}\\]\nWir definieren die Folge:\n\\[\\begin{align*}\n    c(n) &:= \\frac{n\\log(n)}{\\sum_{i=1}^{n}\\log(i)} \\\\\n         &= \\frac{\\overbrace{\\log(n) + \\dots + \\log(n)}^\\text{n-mal}}{\\log(1) + \\dots + \\log(n)}\n\\end{align*}\\]\nWir behaupten ohne Beweis, dass \\(c(n)\\) eine monoton fallende Folge ist. D.h. es gilt:\n\\[\nc(n) \\leq c(m), \\quad \\forall n \\geq m\n\\]\nSetze nun \\(n_0 := 10, c_0 := c(10) = \\frac{10\\log(10)}{\\sum_{i = 1}^{10}\\log(i)}\\). Somit folgt:\n\\[\\begin{align*}\n    n\\log(n) &\\leq \\left(\\frac{n\\log(n)}{\\sum_{i=1}^{n}\\log(i)}\\right)\\log(n!) \\\\\n             &= c(n)\\log(n!) \\\\\n             &\\leq c_0\\log(n!), \\quad \\forall n\\geq n_0 = 10 \\tag{$c(n)$ monoton fallend}\n\\end{align*}\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Blatt 1</span>"
    ]
  },
  {
    "objectID": "01/01.html#aufgabe-3",
    "href": "01/01.html#aufgabe-3",
    "title": "1  Blatt 1",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\n\na)\nDa \\(f_1 \\in  \\mathcal{O}(g_1)\\) und \\(f_2 \\in  \\mathcal{O}(g_2)\\) existieren \\(n_1, n_2, c_1, c_2\\) s.d:\n\\[\\begin{align*}\nf_1(n) \\leq c_1 g_1(n), \\quad \\forall n\\geq n_1 \\\\\nf_2(n) \\leq c_2 g_2(n), \\quad \\forall n\\geq n_2\n\\end{align*}\\]\nSetze \\(c_0 := max\\{c_1, c_2\\}, n_0 := max\\{n_1, n_2\\}\\). Dann gilt\n\\[\\begin{align*}\n    (f_1 + f_2)(n) &= f_1(n) + f_2(n)  \\\\\n                   &\\leq c_1g_1(n) + c_2g_2(n), \\quad \\forall n \\geq n_0\n                   \\tag{$n \\geq n_0 \\Rightarrow n \\geq n_1 \\wedge n \\geq n_2$} \\\\\n                   &\\leq c_0g_1(n) + c_0g_2(n), \\quad \\forall n \\geq n_0 \\\\\n                   &= c_0(g_1 + g_2)(n) \\quad \\forall n \\geq n_0 \\\\\n    \\iff   f_1 + f_2 &\\in \\mathcal{O}(g_1 + g_2) \\tag{Def $\\mathcal{O}$}\n\\end{align*}\\]\n\n\nb)\nmit \\(f_1 \\in \\Theta(g_1), f_2 \\in \\Theta(g_2)\\) existieren \\(a_1, a_2, b_1, b_2, n_1, n_2\\), s.d.:\n\\[\\begin{align*}\n    a_1f_1(n) \\leq g_1(n) \\leq a_2f_1(n), \\forall n \\geq n_1 \\\\\n    b_1f_2(n) \\leq g_2(n) \\leq b_2f_2(n), \\forall n \\geq n_2 \\\\\n\\end{align*}\\]\nSetze \\(n_0 := max\\{n_1, n_2\\}, \\, c_1 := a_1b_1, \\, c_2 := a_2b_2\\). Dann gilt:\n\\[\nc_1(f_1f_2)(n) = a_1f_1(n)b_1f_2(n) \\leq (g_1g_2)(n) \\leq a_2f_1(n)b_2f_2(n) = c_2(f_1f_2)(n), \\quad \\forall n \\geq n_0\n\\]\nSomit \\(f_1f_2 \\in \\Theta(g_1g_2)\\).\n\n\nc) Falsch:\nBetrachte \\(f(n) := n\\) und \\(g(n) := 10n\\). Offensichtlicht gilt \\(f \\in \\Omega(g)\\) mit \\(c_0 := 1/10, n_0 := 1\\). Aber \\(2^{n} \\notin \\Omega(2^{10n})\\), da \\(2^n\\) langsamer als \\(2^{10n}\\) waechst. (Setze z.B. \\(2^n := x\\). Dann \\(2^{10n} = (2^{n})^{10} = x^{10}\\), und \\(x^{10}\\) ist offensichtlich schneller als \\(x\\))\n\n\nd) Falsch:\nSei \\(g(n) := 2^n\\). Dann \\(f(n) = g(2n) = 2^{2n} = (2^n)^2\\). \\((2^n)^2\\) ist offensichtlich schneller als \\(2^n\\)\n\n\ne) Falsch:\nSeien \\(f(n) := n^2, f_1(n) := n^3, f_2(n) := n\\). Es gilt:\n\\[\\begin{align*}\n    f\\in \\mathcal{O}(f_1) \\tag{$n^2 \\in \\mathcal{O}(n^3)$} \\\\\n    f_1\\in \\Omega(f_2) \\tag{$n^3 \\in \\Omega(n)$}\n\\end{align*}\\]\naber\n\\[\nf \\notin \\mathcal{O}(f_2) \\tag{$n^2 \\notin \\mathcal{O}(n)$}\n\\]\n\n\nf)\nEs gilt:\n\\[\\begin{align*}\n    \\lim_{n\\to\\infty}\\frac{f(n)}{f_2(n)} &=\n                \\lim_{n\\to\\infty}\\left(\\frac{f(n)}{f_1(n)}\\cdot\\frac{f_1(n)}{f_2(n)}\\right) \\\\\n                                         &=\n                \\lim_{n\\to\\infty}\\left(\\frac{f(n)}{f_1(n)}\\right) \\cdot\n                \\lim_{n\\to\\infty}\\left(\\frac{f_1(n)}{f_2(n)}\\right) \\\\\n                                         &= 0\\cdot c, \\text{fuer ein} c\n                                         \\tag{$f \\in \\mathcal{o}(f_1), f_1 \\in\\mathcal{O}(f_2)$} \\\\\n                                         &= 0 \\\\\n                                \\iff f \\in \\mathcal{o}(f_2) \\tag{Def $\\mathcal{o}$}\n\\end{align*}\\]\nWobei wir die alternativen Definitionen von \\(\\mathcal{o}(\\bullet)\\) und \\(\\mathcal{O}(\\bullet)\\) benutzt haben.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Blatt 1</span>"
    ]
  },
  {
    "objectID": "01/01.html#auafgabe-4",
    "href": "01/01.html#auafgabe-4",
    "title": "1  Blatt 1",
    "section": "Auafgabe 4",
    "text": "Auafgabe 4\n\na)\n\\(\\mathcal{O}(n^2\\log(n))\\):\nread(n) //input\nfor i := 1 to n :\n    for j := 1 to n:\n        k := 1\n        // O(log(n))\n        while (k &lt; n) : \n            k := 2 * k\n\n\nb)\n\\(\\mathcal{O}((log(n))^2)\\):\nread(n) //input\ni := 1\nwhile (i &lt; n) :\n    j := 1\n    while (j &lt; n) :\n        j := 2 * j \n    i := 2 * i\n\n\nc)\nWir ‘simulieren’ Exponentiation durch einzelne Additionsoperationen. Somit ist \\(n^n\\) in \\(n^n\\) Additionen berechnet - Python Implementierung:\n\ndef add(n, m) :\n    if m == 0 : return n\n    return 1 + add(n, m - 1)\n\ndef mult(n, m) :\n    if m == 0 : return 0\n    return add(n, mult(n, m - 1))\n\ndef exp(n, m) :\n    if m == 0 : return 1\n    return mult(n, exp(n, m - 1))\n\ndef f(n) : return exp(n, n)\n\nWir testen diese Funktion fuer einige Werte:\n\nfor i in range(5) :\n    print(f(i))\n\n1\n1\n4\n27\n256\n\n\nAlternativ betrachte folgende rekursive Funktionsdefinition:\nfunction recursiveLoops(n : Nat, m : Nat) :\n    if m &gt; 0 then :\n        for i = 1 ... n do :\n            recursiveLoops(n, m - 1)\nDann erzeugt der Aufruf recursiveLoops(n, n)eine Anzahl von \\(\\mathcal{O}(n^n)\\) rekursiven Aufrufe.\n\n\nd)\n\\(\\Theta{2^n}\\) - Wir ‘simulieren’ binaeres Zaehlen:\nread(n)\nbase := 0\ncount := 0\nk := 1 \n// invariant: k == 2^b, count &lt; k\nwhile (base &lt; n) :\n    k := 2 * k\n    base := base + 1\n    while (count &lt; k) :\n        count := count + 1\n    // post-condition: count == k\n//post-condition b == n =&gt; count == 2^n\nPython Implementierung:\n\ndef binary_count(n) :\n    base = count = 0\n    k = 1\n    while (base &lt; n) :\n        k = 2 * k\n        base = base + 1\n        while (count &lt; k) :\n            count = count + 1\n    return count\n\nWir testen diese Funktion fuer einige Werte. Das Ergebniss ist die Anzahl der Schritte fuer die jeweilige Eingabe:\n\nfor i in range(11) :\n    print(binary_count(i))\n\n0\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n\n\nAlternativ:\nfunction f(n) :\n    if n == 0 : return 1\n    return f(n - 1) + f(n - 1)\nDiese rekursive Funktion ruft sich selbst zweimal fuer jeden Wert von \\(n\\) auf, was zu einer Laufzeit von \\(2^n\\) fuehrt.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Blatt 1</span>"
    ]
  },
  {
    "objectID": "02/02.html",
    "href": "02/02.html",
    "title": "2  Blatt 2",
    "section": "",
    "text": "Aufgabe 1",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Blatt 2</span>"
    ]
  },
  {
    "objectID": "02/02.html#aufgabe-1",
    "href": "02/02.html#aufgabe-1",
    "title": "2  Blatt 2",
    "section": "",
    "text": "1 Rekursionsbaum\nRekursionsbaum des Aufrufs sum(&lt;1, 2, 3, 4, 5, 6, 7, 8&gt;)\n\n\n\n\n\n\nFigure 2.1: Rekursionsbaum\n\n\n\nDie Nummerierung der Knoten entspricht der Berechnungsreihenfolge.\n\n\n2 Array Zerlegung\nEine nicht-konstante Laufzeit ensteht, falls uebergebene arrays auf den Stack des Funktionsaufrufs kopiert werden muessen.\nWenn eine gegebene Implementierung der Programmiersprache folgende zwei Eigenschaften aufweist, kann dies vermieden werden:\n\nDie Groesse eines Arrays ist immer als zusaetzliche Information beinhaltet.\nDie Funktionsaufrufe werden per-default als call by reference realisiert statt call by value.\n\nSo wuerde fuer einen existierenden Array \\(A : \\text{Array} [0 .. n - 1] \\text{ of } \\mathbb{N}\\) der allgeimeiner Ausdruck \\(A[l..k]\\) einen Array liefern, dessen Anfang-position im Speicher und Groesse durch Pointerarithmetik, bzw durch den Ausdruck \\(k - l + 1\\) bestimmt werden koennen. Das sind nur zwei Grundoperationen, und somit \\(\\mathcal{O}(1)\\)\nDa die Uebergabe der Arrays per Referenz stattfindet, wuerden die Aufrufe sum(A[0..m-1]) und sum(A[m..n-1]) nur konstante Zeit bei der Initialisuerungen auf ihren Function call-stacks benoetigen.\n\n\n3 Laufzeit\n\nDie Laufzeit erfuellt die Rekurrenzgleichung:\n\n\\[\\begin{align*}\n    T(1) &= 1\\\\\n    T(n) &= 1 + 2\\cdot T(\\frac{n}{2}) \\tag{fuer $n = 2^k &gt; 1$}\n\\end{align*}\\]\n\nDa, die Eingabe bei jedem Aufruf halbiert wird ist die Tiefe des Rekurrenzbaums (Figure 2.1) \\(k = \\log_2(n)\\). Dieser Baum ist vollstaendig binaer, deshalb enthaelt jede Tiefe \\(i\\) genau \\(2^i\\) Knoten, fuer \\(i=0\\dots k\\). Somit betreagt die Gesamtzahl der Knoten:\n\n\\[\\begin{align*}\n    N &= \\sum_{i=0}^{\\log_2(n)}2^i \\\\\n      &= 2^{\\log_2(n) + 1} - 1 \\tag{Geom Reihe} \\\\\n      &= 2n - 1\n\\end{align*}\\]\nBei jedem Knoten wird eine konstante Anzahl von Additions- & Zuweisungsoperationen durchgefuehrt, und das Ergebnis zur aufrufenden Funktion zurueckgegeben. Somit ist die Laufzeit proportional zur Anzahl der Knoten, die wir in der vorangehenden Diskussion berechnet haben, d.h. \\(T(n) = c_1n + c_2\\). Dann gilt offensichtlich \\(T(n) = \\Theta(n)\\)\n\n\n4 Laufzeit Parallel\nDa, der zweite rekursive Aufruf bereits berechnet ist zum Zeitpunkt der erste Fertig ist, muss sein Zeitaufwand nicht zuesaetzlich addiert werden. Somit erfuellt fuer diesen Fall die Laufzeit folgende Rekurrenzgleichung:\n\\[\\begin{align*}\n    T(1) &= 1\\\\\n    T(n) &= 1 + T(\\frac{n}{2}) \\tag{fuer $n = 2^k &gt; 1$}\n\\end{align*}\\]\nEs ist leicht zu sehen, dass \\(\\log_2(n)\\) diese Rekurrenzgleichung erfuellt. (Formaler Beweis durch Induktion). Dann \\(T(n) = \\mathcal{O}(\\log(n))\\)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Blatt 2</span>"
    ]
  },
  {
    "objectID": "02/02.html#aufgabe-2",
    "href": "02/02.html#aufgabe-2",
    "title": "2  Blatt 2",
    "section": "Aufgabe 2",
    "text": "Aufgabe 2\n\na)\n\\[\\begin{align*}\n    & a = 1, \\\\\n    &c = \\tilde{c}, \\\\\n    &d = 1 &lt; 2 = b \\\\\n    \\Rightarrow &T(n) \\in \\Theta(n) \\tag{Fall $d &lt; b$ des MT}\n\\end{align*}\\]\n\n\nb)\n\\[\\begin{align*}\n    & a = 1, \\\\\n    &c = 4, \\\\\n    &d = 9 &gt; 3 = b \\\\\n    \\Rightarrow &T(n) \\in \\Theta(n^{\\log_3(9)}) = \\Theta(n^2) \\tag{Fall $d &gt; b$ des MT}\n\\end{align*}\\]\n\n\nc)\nDer Ausdruck \\(C(n/4) + n + 6\\) kann asymptotisch als \\(C(n/4) + n\\) kann vereinfacht werden, da Addition mit konstante vernachlaessigt werden kann. Somit:\n\\[\\begin{align*}\n    & a = 1, \\\\\n    &c = 1, \\\\\n    &d = 1 &lt; 4 = b \\\\\n    \\Rightarrow &T(n) \\in \\Theta(n) \\tag{Fall $d &lt; b$ des MT}\n\\end{align*}\\]\n\n\nd)\nIn c) wurde gezeigt, dass \\(C(n) \\in \\Theta(n)\\). Somit kann \\(C(n)\\) fuer asymptotische Zwecke durch \\(c\\cdot n\\) erzetzt werden. Dann gilt:\n\\[\nT(n) = c\\cdot n + 4D(\\frac{n}{4})\n\\]\nund somit:\n\\[\\begin{align*}\n    &a = 1, \\\\\n    &d = 4 = 4 = b \\\\\n    \\Rightarrow &T(n) \\in \\Theta(n\\log n) \\tag{Fall $d = b$ des MT}\n\\end{align*}\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Blatt 2</span>"
    ]
  },
  {
    "objectID": "02/02.html#aufgabe-3",
    "href": "02/02.html#aufgabe-3",
    "title": "2  Blatt 2",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\n\n1 Doubly Linked List\nWir gehen von einer Implementierung aus, die das Dummy-element verwendent, wie in der VL beschrieben.\nIdee: Tausche fuer jedes List-Item die Pointer next und prev aus. Illustration:\n\n\n\nReverse DLList\n\n\n\nPseudocode implementierung:\n\nprocedure reverse(X : List&lt;T&gt;)\n    assert(not X.is_empty())\n    // let initially X == &lt;e1, ..., e_n&gt;\n\n    // exchange dummy's prev and next pointers\n    ip := X.first() : *Item&lt;T&gt;\n    X.first() := X.last()\n    X.last() := ip\n\n    // invariant: reversed from e1 up-to (excluding) *ip\n    while (ip-&gt;next != &dummy)\n        //exchange next and prev of the item pointed by ip\n        ip_next := ip-&gt;next : *Item&lt;T&gt;\n        ip-&gt;next := ip-&gt;prev\n        ip-&gt;prev := ip_next\n        ip = ip_next //increment to next item\n    //post-loop: *ip == e_n \n\n    // take care of e_n's pointers:\n    ip.next = ip.prev\n    ip.prev = &dummy\n\nSiehe Kommentare fuer den Beweis der Korrektheit\nDer Algorithmus benoetigt keine zusaetzliche Worte, da es keine neue Listenelemente abgelegt oder existierende Elemente kopiert werden. Es werden einfach nur Pointer ausgetauscht.\nDie Listenelemente werden sequentiell durchgelaufen und fuer jedes Element werden eine konstante Anzahl von Grundoperationen durchgefuehrt \\(\\Rightarrow \\mathcal{O}(n)\\).\n\n\n\n2 Array\nIdee: Tausche die ‘aussersten’ noch nicht ausgetauschten Elementen aus, und inkrementiere zu den inneren. Siehe das Bild:\n\n\n\nReverse Array\n\n\n\nPseudocode:\n\nprocedure reverse(X: Array[0..n-1] of Nat)\n    i := 0 : Nat\n    // invariant: the X[0..i-1] and X[(n-1) - (i-1) .. n-1]\n    // portions of X are reversed\n    while (i &lt; n/2)\n        temp := X[i] : Nat\n        X[i] := X[(n-1) - i]\n        X[(n-1) - i] := temp\n        i := i + 1\n    //post-loop: i == ceiling(n/2)\nPython Beispiel:\n\ndef reverse(X) :\n    i = 0\n    n = len(X)\n    while (i &lt; n/2) :\n        temp = X[i]\n        X[i] = X[(n-1) - i]\n        X[(n-1) - i] = temp\n        i = i + 1\n    return X\n    \nX = [1, 2, 3, 4]\nY = [1, 2, 3, 4, 5]\nZ = [1, 2, 3, 4, 5, 6]\n\nprint(reverse(X))\nprint(reverse(Y))\nprint(reverse(Z))\n\n[4, 3, 2, 1]\n[5, 4, 3, 2, 1]\n[6, 5, 4, 3, 2, 1]\n\n\n\nSiehe die Kommentare im Pseudocode fuer den Beweis der Korrektheit\nDer Algorithmus verwendet keine neue Worte, da die Eintrage des Arrays “in-place” ausgetauscht werden. D.h. der vorhandene Array wird ueberschrieben\nDer Algorithmus besteht aus einer while-schleife mit \\(n/2\\) iterationen \\(\\Rightarrow \\Theta(n)\\).\n\n\n\n3 Simply Linked List\nIdee: Gehe die Liste durch und drehe die Pointer fuer jedes Listenelement um. Siehe das Bild:\n\n\n\nReverse SList\n\n\n\nPseudocode:\n\nreverse(X : SList&lt;T&gt;)\n    assert(not X.is_empty())\n    // let &lt;e1,...,e_n&gt; be the initial contents of the list \n    // i.e. initially X == &lt;e1,...,e_n&gt;\n    ip := X.first() : *Item&lt;T&gt;      //*ip == e1\n    ip_next := ip-&gt;next : *Item&lt;T&gt;  //*ip_next == e2\n    ip-&gt;next := &dummy          //e1 is now last\n\n    //invariant: \n    // (*ip == e_k) =&gt; \n    // *ip_next == e_(k+1))\n    //   && \n    //reversed from e1 to e_k, i.e. X == &lt;..TBD..,e_k, ..., e1&gt;\n    while (ip_next != &dummy)\n        ip_next_next := ip_next-&gt;next : *Item&lt;T&gt;\n        ip_next-&gt;next := ip\n        ip := ip_next\n        ip_next := ip_next_next\n    //post-loop: *ip == e_n\n    \n    // take care of dummy's next pointer\n    X.first() := ip \n\nSiehe Kommentare im Pseudocode\nNur Pointer werden ueberschrieben \\(\\Rightarrow\\) keine extra Speicherbelegung.\nSequentielle Bearbeitung der Listenelemente \\(\\Rightarrow \\Theta(n)\\)\n\n\n\n4 Fast Reverse\nDas ist nicht moeglich, da Kopieren einer Liste oder eines Arrays der Laenge \\(n\\) \\(\\mathcal{O}(n)\\) Operationen benoetigen wuerde. Unsere “in-place” Algorithmen sind bereits \\(\\mathcal{O}(n)\\)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Blatt 2</span>"
    ]
  }
]